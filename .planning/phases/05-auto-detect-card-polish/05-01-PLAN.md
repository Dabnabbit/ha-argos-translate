---
phase: 05-auto-detect-card-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - custom_components/argos_translate/api.py
  - custom_components/argos_translate/coordinator.py
  - custom_components/argos_translate/services.py
  - custom_components/argos_translate/const.py
  - custom_components/argos_translate/strings.json
  - custom_components/argos_translate/translations/en.json
  - tests/test_services.py
autonomous: true
requirements:
  - DTCT-02
  - DTCT-03
  - DTCT-06

must_haves:
  truths:
    - "Service call with source='auto' returns translated text plus detected_language and detection_confidence fields"
    - "Service call with source='auto' does not raise ServiceValidationError for unknown source"
    - "When detected language code is not in installed languages, response includes uninstalled_detected_language warning field"
    - "api.py /detect endpoint returns array of candidate objects with language and confidence"
    - "HA detect service is callable from the card and returns candidate languages array"
  artifacts:
    - path: "custom_components/argos_translate/api.py"
      provides: "async_translate returns full dict; new async_detect_languages method"
      contains: "async_detect_languages"
    - path: "custom_components/argos_translate/coordinator.py"
      provides: "Passthrough for async_translate (dict return) and async_detect_languages"
      contains: "async_detect_languages"
    - path: "custom_components/argos_translate/services.py"
      provides: "Auto source bypass, detection fields in response, uninstalled language warning, detect service"
      contains: "detected_language"
    - path: "custom_components/argos_translate/const.py"
      provides: "SERVICE_DETECT constant"
      contains: "SERVICE_DETECT"
    - path: "tests/test_services.py"
      provides: "Tests for auto-detect translate, detection response fields, uninstalled language warning"
      contains: "test_translate_auto_detect"
  key_links:
    - from: "custom_components/argos_translate/api.py"
      to: "LibreTranslate /translate endpoint"
      via: "async_translate returns full response dict including detectedLanguage"
      pattern: 'return await self._request\("POST", "/translate"'
    - from: "custom_components/argos_translate/services.py"
      to: "custom_components/argos_translate/coordinator.py"
      via: "coordinator.async_translate returns dict, services extracts detected_language"
      pattern: 'result\["translatedText"\]'
    - from: "custom_components/argos_translate/services.py"
      to: "custom_components/argos_translate/coordinator.py"
      via: "detect service calls coordinator.async_detect_languages for candidate array"
      pattern: "async_detect_languages"
---

<objective>
Add backend auto-detect language support to the translate service.

Purpose: Enable the HA service layer to accept `source: "auto"`, pass it through to LibreTranslate, and return detected language metadata alongside the translation. Also add a `/detect` API method for fetching multiple detection candidates. This is the foundation for the card's auto-detect UI.

Output: Updated api.py, coordinator.py, services.py with auto-detect support; updated strings.json and translations/en.json; updated test_services.py with auto-detect test coverage.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-auto-detect-card-polish/05-RESEARCH.md
@custom_components/argos_translate/api.py
@custom_components/argos_translate/coordinator.py
@custom_components/argos_translate/services.py
@custom_components/argos_translate/strings.json
@custom_components/argos_translate/translations/en.json
@tests/test_services.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend api.py and coordinator.py for auto-detect</name>
  <files>
    custom_components/argos_translate/api.py
    custom_components/argos_translate/coordinator.py
  </files>
  <action>
**api.py changes:**

1. Change `async_translate` return type from `str` to `dict[str, Any]`. Instead of returning `result["translatedText"]`, return the full response dict from LibreTranslate. This is because when `source: "auto"` is passed, LibreTranslate includes a `detectedLanguage` object (`{"language": "fr", "confidence": 83.0}`) in the response alongside `translatedText`. Update the docstring accordingly.

2. Add new method `async_detect_languages`:
```python
async def async_detect_languages(self, text: str) -> list[dict[str, Any]]:
    """Detect language candidates for text using LibreTranslate /detect endpoint.

    Returns list of candidates: [{"language": "fr", "confidence": 91.0}, ...]
    sorted by descending confidence.
    """
    payload: dict[str, str] = {"q": text}
    if self._api_key:
        payload["api_key"] = self._api_key
    return await self._request("POST", "/detect", json=payload)
```

**coordinator.py changes:**

1. Update `async_translate` return type from `str` to `dict[str, Any]`. It simply delegates to `self.client.async_translate` so the dict flows through unchanged. Update docstring.

2. Add passthrough method:
```python
async def async_detect_languages(self, text: str) -> list[dict[str, Any]]:
    """Detect language candidates for text via the API client."""
    return await self.client.async_detect_languages(text)
```

Import `Any` from typing in coordinator.py if not already imported (it IS already imported via `dict[str, Any]` in the class definition).
  </action>
  <verify>
Run `python -c "import ast; ast.parse(open('custom_components/argos_translate/api.py').read()); ast.parse(open('custom_components/argos_translate/coordinator.py').read()); print('OK')"` to confirm both files parse correctly.
  </verify>
  <done>
api.py `async_translate` returns full response dict instead of just the translated text string. api.py has new `async_detect_languages` method hitting `/detect`. coordinator.py passes through both methods with correct return types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update services.py for auto-detect with validation bypass, detection response fields, and detect service</name>
  <files>
    custom_components/argos_translate/services.py
    custom_components/argos_translate/const.py
    custom_components/argos_translate/strings.json
    custom_components/argos_translate/translations/en.json
  </files>
  <action>
**const.py changes:**

1. Add a new constant alongside existing `SERVICE_TRANSLATE`:
```python
SERVICE_DETECT = "detect"
```

2. Add attribute constant for the detect service:
```python
ATTR_DETECT_TEXT = "text"
```
(ATTR_TEXT already exists and can be reused, but add ATTR_DETECT_TEXT only if you prefer a separate constant — otherwise reuse ATTR_TEXT for the detect service schema too.)

Actually, just reuse `ATTR_TEXT` since the detect service takes the same "text" field. Only add `SERVICE_DETECT = "detect"` to const.py.

**services.py changes:**

1. Add constant at module level: `AUTO_SOURCE = "auto"`

2. Update the import from `.const` to include `SERVICE_DETECT`:
```python
from .const import ATTR_SOURCE, ATTR_TARGET, ATTR_TEXT, DOMAIN, SERVICE_DETECT, SERVICE_TRANSLATE
```

3. In `_async_handle_translate`, bypass the source language validation when `source == AUTO_SOURCE`. The current code finds `source_lang` in the languages list and raises `ServiceValidationError` if not found. Wrap that validation block in `if source != AUTO_SOURCE:` — when source is "auto", skip both the source existence check AND the target-in-source-targets check (since auto-detect means we don't know the source language yet, all targets are potentially valid).

4. Update the response building. Since `coordinator.async_translate` now returns a dict (not a string), change:
```python
# OLD:
translated_text = await coordinator.async_translate(text, source, target)
return {"translated_text": translated_text}

# NEW:
result = await coordinator.async_translate(text, source, target)
response: dict = {"translated_text": result["translatedText"]}

if "detectedLanguage" in result:
    dl = result["detectedLanguage"]
    detected_code = dl.get("language")
    detected_confidence = dl.get("confidence")
    response["detected_language"] = detected_code
    response["detection_confidence"] = detected_confidence

    # Check if detected language is installed (DTCT-06)
    if detected_code:
        installed_codes = [lang["code"] for lang in languages]
        if detected_code not in installed_codes:
            response["uninstalled_detected_language"] = detected_code

return response
```

5. **Register a new `detect` service** in `async_register_services`. Add a new handler and registration after the translate service:

```python
DETECT_SCHEMA = vol.Schema(
    {
        vol.Required(ATTR_TEXT): cv.string,
    }
)

async def _async_handle_detect(call: ServiceCall) -> ServiceResponse:
    """Handle the detect service call — returns language detection candidates."""
    text: str = call.data[ATTR_TEXT]

    entries = hass.config_entries.async_entries(DOMAIN)
    if not entries:
        raise ServiceValidationError(
            translation_domain=DOMAIN,
            translation_key="no_config_entry",
        )

    entry = entries[0]
    coordinator = entry.runtime_data.coordinator

    try:
        candidates = await coordinator.async_detect_languages(text)
    except CannotConnectError as err:
        raise HomeAssistantError(
            f"Language detection failed: {err}"
        ) from err

    return {"detections": candidates}

hass.services.async_register(
    DOMAIN,
    SERVICE_DETECT,
    _async_handle_detect,
    schema=DETECT_SCHEMA,
    supports_response=SupportsResponse.ONLY,
)
```

6. Update the service description in `strings.json` to:
   - Document that `source` accepts "auto" for auto-detection: In `services.translate.fields.source.description`, change to: `"The source language code (e.g., 'en' for English, or 'auto' for auto-detection)."`
   - Add a new `services.detect` block:
```json
"detect": {
  "name": "Detect language",
  "description": "Detect the language of the given text using LibreTranslate. Returns an array of candidate languages with confidence scores.",
  "fields": {
    "text": {
      "name": "Text",
      "description": "The text to detect the language of."
    }
  }
}
```
   Mirror both changes in `translations/en.json`.

7. Do NOT add "auto" to any language validation lists — the bypass is explicit via the `if source != AUTO_SOURCE` guard.
  </action>
  <verify>
Run `python -c "import ast; ast.parse(open('custom_components/argos_translate/services.py').read()); ast.parse(open('custom_components/argos_translate/const.py').read()); print('OK')"` to confirm both files parse. Run `python -c "import json; json.load(open('custom_components/argos_translate/strings.json')); json.load(open('custom_components/argos_translate/translations/en.json')); print('OK')"` to confirm valid JSON. Then run `pytest tests/test_services.py -x -v` — existing tests should still pass (they use `source: "en"` which hits the non-auto path). Note: existing tests mock `coordinator.async_translate` to return a string `"Hola"` — these must be updated in Task 3 since the return type is now a dict.
  </verify>
  <done>
services.py accepts `source: "auto"` without raising ServiceValidationError. Response includes `detected_language` and `detection_confidence` when auto-detect is used. Response includes `uninstalled_detected_language` when the detected language code is not in the installed languages list. New `detect` HA service is registered that calls `coordinator.async_detect_languages` and returns the candidates array. `SERVICE_DETECT` constant added to const.py. strings.json and translations/en.json updated with both translate source description change and new detect service.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update test_services.py for auto-detect and fix existing tests for dict return type</name>
  <files>
    tests/test_services.py
  </files>
  <action>
**Fix existing tests for new return type:**

The `_setup_service` helper currently mocks `coordinator.async_translate` to return a string (`"Hola"`). Since `async_translate` now returns a dict, update the mock:

```python
async def _setup_service(
    hass: HomeAssistant, mock_result: dict | None = None
) -> tuple[MockConfigEntry, MagicMock]:
    """Set up the translate service with a mocked coordinator."""
    if mock_result is None:
        mock_result = {"translatedText": "Hola"}
    # ... rest stays the same except:
    mock_coordinator.async_translate = AsyncMock(return_value=mock_result)
```

Update `test_translate_success` to pass `mock_result={"translatedText": "Hola"}` (via the new default) and assert `result == {"translated_text": "Hola"}` (unchanged).

**Add new auto-detect tests:**

1. `test_translate_auto_detect_success`: Call with `source: "auto"`. Mock coordinator to return `{"translatedText": "Hello", "detectedLanguage": {"language": "fr", "confidence": 92.0}}`. Assert response contains `translated_text`, `detected_language` == "fr", `detection_confidence` == 92.0.

2. `test_translate_auto_detect_uninstalled_language` (DTCT-06): Call with `source: "auto"`. Mock coordinator to return `{"translatedText": "Hello", "detectedLanguage": {"language": "zh", "confidence": 85.0}}` — note "zh" is NOT in MOCK_LANGUAGES. Assert response contains `uninstalled_detected_language` == "zh".

3. `test_translate_auto_detect_no_validation_error`: Call with `source: "auto"`, `target: "es"`. Confirm no `ServiceValidationError` is raised (the "auto" source bypasses validation).

Keep existing tests working — the dict return change affects `test_translate_success` mock but the assertion stays the same since the service still returns `{"translated_text": "Hola"}`.
  </action>
  <verify>
Run `pytest tests/test_services.py -x -v` — all existing tests pass plus the 3 new auto-detect tests pass.
  </verify>
  <done>
All service tests pass. Auto-detect success, uninstalled language warning, and validation bypass are covered. Existing tests updated for dict return type without changing their assertions.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/test_services.py -x -v` — all tests pass (existing + new auto-detect tests)
2. `python -c "import ast; ast.parse(open('custom_components/argos_translate/api.py').read()); ast.parse(open('custom_components/argos_translate/coordinator.py').read()); ast.parse(open('custom_components/argos_translate/services.py').read()); print('All files parse OK')"` — confirms no syntax errors
3. Verify strings.json is valid JSON: `python -c "import json; json.load(open('custom_components/argos_translate/strings.json')); print('OK')"`
</verification>

<success_criteria>
- `source: "auto"` accepted by translate service without validation error
- Service response includes `detected_language` and `detection_confidence` when auto-detect used
- Service response includes `uninstalled_detected_language` when detected code not in installed languages
- api.py has `async_detect_languages` method for `/detect` endpoint
- `detect` HA service registered and callable, returns `{"detections": [...]}` with candidate language/confidence objects
- All tests pass including 3+ new auto-detect tests
</success_criteria>

<output>
After completion, create `.planning/phases/05-auto-detect-card-polish/05-01-SUMMARY.md`
</output>
