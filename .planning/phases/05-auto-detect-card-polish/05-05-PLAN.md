---
phase: 05-auto-detect-card-polish
plan: "05"
type: execute
wave: 1
depends_on: []
files_modified:
  - custom_components/argos_translate/api.py
  - custom_components/argos_translate/services.py
  - tests/test_services.py
autonomous: true
gap_closure: true
requirements:
  - DTCT-02
  - DTCT-03
  - DTCT-05
  - DTCT-06
  - CPOL-01

must_haves:
  truths:
    - "Status indicator (binary_sensor) flips to offline immediately when a translation service call hits CannotConnectError — no waiting for 5-min poll"
    - "Auto-detect with source='auto' returns detected_language info even when the translation pair is unavailable (HTTP 400)"
    - "HTTP 400 from LibreTranslate is distinguishable from true connection failures in api.py"
  artifacts:
    - path: "custom_components/argos_translate/api.py"
      provides: "TranslationError exception for HTTP 4xx non-auth errors"
      contains: "class TranslationError"
    - path: "custom_components/argos_translate/services.py"
      provides: "async_set_update_error for immediate status flip; detect-first fallback for auto source"
      contains: "async_set_update_error"
    - path: "tests/test_services.py"
      provides: "Tests for new error handling and auto-detect fallback"
  key_links:
    - from: "services.py CannotConnectError handler"
      to: "coordinator.async_set_update_error(err)"
      via: "synchronous @callback — no debouncing"
      pattern: "async_set_update_error"
    - from: "services.py auto-detect path"
      to: "coordinator.async_detect_languages()"
      via: "detect-first call before translate attempt"
      pattern: "async_detect_languages"
---

<objective>
Fix two backend issues found in UAT re-test: (1) status indicator not flipping to offline immediately on connection failure, and (2) auto-detect failing with generic error when translation pair is unavailable.

Purpose: The binary_sensor status indicator must reflect server state immediately — not after a 5-min poll. Auto-detect must surface the detected language even when the specific pair cannot be translated.

Output: Updated api.py, services.py, and test_services.py with both fixes verified by pytest.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-auto-detect-card-polish/05-04-SUMMARY.md
@.planning/debug/status-indicator-still-green.md
@.planning/debug/auto-detect-fails-invalid-pair.md
@custom_components/argos_translate/api.py
@custom_components/argos_translate/services.py
@tests/test_services.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix status indicator with async_set_update_error and add TranslationError to api.py</name>
  <files>
    custom_components/argos_translate/api.py
    custom_components/argos_translate/services.py
  </files>
  <action>
**Part A — api.py: Add TranslationError exception class and use it for HTTP 4xx**

Add a new exception class `TranslationError(Exception)` alongside `CannotConnectError` and `InvalidAuthError`. This represents semantic/validation errors from the server (HTTP 4xx excluding 401/403) — distinct from connection failures.

In `_request()`, change the HTTP 400+ handler (lines 67-70):
- BEFORE: `if response.status >= 400: raise CannotConnectError(...)`
- AFTER: `if response.status >= 400: raise TranslationError(f"Server returned HTTP {response.status}: {response.reason}")`

This preserves the existing behavior for connection errors (aiohttp exceptions, timeouts) as `CannotConnectError` while giving HTTP 4xx client errors (like "pair not available") a distinct type.

**Part B — services.py: Replace async_request_refresh with async_set_update_error**

In `_async_handle_translate` CannotConnectError handler (lines 89-95):
- Replace `await coordinator.async_request_refresh()` with `coordinator.async_set_update_error(err)`
- Remove `await` — `async_set_update_error` is a synchronous `@callback`, no await needed
- Keep the `raise HomeAssistantError(...)` on the next line

In `_async_handle_detect` CannotConnectError handler (lines 138-144):
- Same change: replace `await coordinator.async_request_refresh()` with `coordinator.async_set_update_error(err)`

Root cause: `async_request_refresh()` uses a Debouncer with REQUEST_REFRESH_DEFAULT_COOLDOWN=10s. When called shortly after integration reload, the debouncer silently drops the request. `async_set_update_error(err)` is a synchronous @callback that immediately sets `last_update_success=False` and calls `async_update_listeners()` — no debouncing, no scheduling delay.

**Part C — services.py: Add TranslationError handling in both service handlers**

Import `TranslationError` from `.api`.

In `_async_handle_translate`, add a new except block AFTER the CannotConnectError handler:
```python
except TranslationError as err:
    raise HomeAssistantError(
        f"Translation failed: {err}"
    ) from err
```
This catches HTTP 4xx errors that are NOT connection failures. No coordinator error update needed since the server IS reachable (it returned a valid HTTP response).

In `_async_handle_detect`, add the same pattern:
```python
except TranslationError as err:
    raise HomeAssistantError(
        f"Language detection failed: {err}"
    ) from err
```
  </action>
  <verify>
Run `cd /home/dab/Projects/ha-argos-translate && python -m pytest tests/test_services.py -v` — all existing 8 tests pass (the `test_translate_api_error` test will need updating in Task 2 since it asserts `async_request_refresh` is called).

Check that `CannotConnectError` is only raised for actual connection/timeout errors, and `TranslationError` is raised for HTTP 4xx.

Verify `async_set_update_error` appears exactly 2 times in services.py (translate + detect handlers).
Verify `async_request_refresh` appears 0 times in services.py.
  </verify>
  <done>
services.py uses coordinator.async_set_update_error(err) in both CannotConnectError handlers. api.py has TranslationError for HTTP 4xx. services.py catches both CannotConnectError and TranslationError separately.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add detect-first fallback for auto source and update tests</name>
  <files>
    custom_components/argos_translate/services.py
    tests/test_services.py
  </files>
  <action>
**Part A — services.py: Detect-first fallback when source='auto'**

In `_async_handle_translate`, restructure the auto-detect path. When `source == AUTO_SOURCE`:

1. FIRST, try to detect the language by calling `coordinator.async_detect_languages(text)` in a try/except (best-effort — if /detect fails, proceed with translate as-is).
2. THEN, attempt the translation with `coordinator.async_translate(text, source, target)`.
3. If the translate call raises `TranslationError` (HTTP 4xx — pair not available), build a PARTIAL response that includes:
   - `translated_text`: empty string `""`
   - `detected_language`: from the /detect result (first candidate above threshold, or from the translate attempt if available)
   - `detection_confidence`: from the /detect result
   - `error`: a descriptive message like `"Translation pair not available: detected [Language] but [Language] → [Target] is not installed"`
   - Still include `uninstalled_detected_language` if applicable
   - Do NOT raise HomeAssistantError — return the partial response so the card can show both the detection result AND the error
4. If the translate call raises `CannotConnectError` (actual server unreachable), call `coordinator.async_set_update_error(err)` and raise `HomeAssistantError` as before (server is truly down — no detection data to surface).

The detect-first approach means:
```python
if source == AUTO_SOURCE:
    # Best-effort detect first
    detect_result = []
    try:
        detect_result = await coordinator.async_detect_languages(text)
    except (CannotConnectError, TranslationError):
        pass  # Will still try translate

    try:
        result = await coordinator.async_translate(text, source, target)
    except TranslationError as err:
        # Server returned 4xx — pair likely unavailable
        # Surface detection info from the /detect call
        response = {"translated_text": "", "error": str(err)}
        if detect_result:
            from .services import AUTO_SOURCE  # already in scope
            # Filter by confidence threshold (same as card-side: 50.0)
            top = next((d for d in detect_result if d.get("confidence", 0) >= 50.0), None)
            if top:
                detected_code = top["language"]
                response["detected_language"] = detected_code
                response["detection_confidence"] = top["confidence"]
                # Compose descriptive error
                target_name = target
                for lang in languages:
                    if lang["code"] == target:
                        target_name = lang.get("name", target)
                        break
                detected_name = detected_code
                for lang in languages:
                    if lang["code"] == detected_code:
                        detected_name = lang.get("name", detected_code)
                        break
                response["error"] = f"Detected {detected_name} but {detected_name} \u2192 {target_name} translation pair is not available."
                # Check if detected language is installed
                installed_codes = [lang["code"] for lang in languages]
                if detected_code not in installed_codes:
                    response["uninstalled_detected_language"] = detected_code
        return response
    except CannotConnectError as err:
        coordinator.async_set_update_error(err)
        raise HomeAssistantError(f"Translation failed: {err}") from err
else:
    # Non-auto source — existing logic
    try:
        result = await coordinator.async_translate(text, source, target)
    except CannotConnectError as err:
        coordinator.async_set_update_error(err)
        raise HomeAssistantError(f"Translation failed: {err}") from err
    except TranslationError as err:
        raise HomeAssistantError(f"Translation failed: {err}") from err
```

**Part B — tests/test_services.py: Update and add tests**

1. Update `test_translate_api_error`: Change assertion from `mock_coordinator.async_request_refresh.assert_called_once()` to `mock_coordinator.async_set_update_error.assert_called_once()`. Add `mock_coordinator.async_set_update_error = MagicMock()` (not AsyncMock — it is a synchronous @callback) to `_setup_service`.

2. Add `test_translate_auto_detect_pair_unavailable`: Set source='auto'. Mock `async_translate` to raise `TranslationError("Server returned HTTP 400: Bad Request")`. Mock `async_detect_languages` to return `[{"language": "fr", "confidence": 92.0}]`. Call translate service with `source="auto", target="es"`. Assert: result is returned (NOT an exception), `result["translated_text"] == ""`, `result["detected_language"] == "fr"`, `result["detection_confidence"] == 92.0`, `"error" in result`.

3. Add `test_translate_auto_detect_pair_unavailable_no_detect`: Same as above but mock `async_detect_languages` to raise `CannotConnectError`. Assert: `TranslationError` from translate is caught and re-raised as `HomeAssistantError` (since there's no detection data to surface, just raise the error).

4. Add `test_translate_translation_error_non_auto`: Mock `async_translate` to raise `TranslationError`. Call with `source="en"` (non-auto). Assert: raises `HomeAssistantError` with "Translation failed:" message. `async_set_update_error` should NOT be called (server is reachable, just returned a 4xx).

Import `TranslationError` at the top of the test file.
  </action>
  <verify>
Run `cd /home/dab/Projects/ha-argos-translate && python -m pytest tests/test_services.py -v` — all tests pass (original 8 updated + 3 new = 11 tests).

Verify no uses of `async_request_refresh` remain in services.py or test_services.py.
  </verify>
  <done>
Auto-detect with source='auto' calls /detect first, then /translate. If /translate returns HTTP 400, the response includes detected_language + descriptive error instead of raising an exception. Tests cover: (1) pair unavailable with detection data, (2) pair unavailable without detection data, (3) TranslationError on non-auto source. Status indicator uses async_set_update_error (verified by updated test).
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_services.py -v` — all tests pass (11 total)
2. `grep -c "async_request_refresh" custom_components/argos_translate/services.py` returns 0
3. `grep -c "async_set_update_error" custom_components/argos_translate/services.py` returns 2
4. `grep -c "TranslationError" custom_components/argos_translate/api.py` returns at least 2 (class def + raise)
5. `grep -c "TranslationError" custom_components/argos_translate/services.py` returns at least 3 (import + catches)
</verification>

<success_criteria>
- Status indicator will flip to offline immediately when CannotConnectError is caught (no debouncer delay)
- Auto-detect returns detected language info even when the translation pair is unavailable
- HTTP 4xx errors are semantically distinct from connection failures
- All tests pass including new tests for the fallback path
</success_criteria>

<output>
After completion, create `.planning/phases/05-auto-detect-card-polish/05-05-SUMMARY.md`
</output>
