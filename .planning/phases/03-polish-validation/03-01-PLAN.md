---
phase: 03-polish-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/conftest.py
  - tests/test_config_flow.py
  - tests/test_coordinator.py
  - tests/test_services.py
  - tests/test_sensor.py
autonomous: true
requirements:
  - DIST-03

must_haves:
  truths:
    - "All existing tests pass after fixing stale template references"
    - "Config flow tests cover happy path, CannotConnect, InvalidAuth, NoLanguages, and duplicate abort"
    - "Coordinator tests cover successful poll and failed poll with correct data shape"
    - "Service tests cover successful translation, invalid source, invalid target, and API error"
    - "Sensor tests cover language count value, attributes, and null data; binary sensor covers online/offline"
  artifacts:
    - path: "tests/conftest.py"
      provides: "Shared fixtures: mock_config_entry, MOCK_LANGUAGES, auto_enable_custom_integrations"
      contains: "MOCK_LANGUAGES"
    - path: "tests/test_config_flow.py"
      provides: "Config flow tests with CONF_NAME, port 5000, InvalidAuth, NoLanguages, options flow"
      contains: "CONF_NAME"
    - path: "tests/test_coordinator.py"
      provides: "Coordinator tests with ArgosCoordinator, async_get_languages, correct data shape"
      contains: "ArgosCoordinator"
    - path: "tests/test_services.py"
      provides: "Translate service tests: success, invalid source, invalid target, API error"
      contains: "async_register_services"
    - path: "tests/test_sensor.py"
      provides: "Sensor entity tests: language count value/attrs, binary sensor is_on"
      contains: "ArgosLanguageCountSensor"
  key_links:
    - from: "tests/test_coordinator.py"
      to: "custom_components/argos_translate/coordinator.py"
      via: "import and patch"
      pattern: "ArgosCoordinator"
    - from: "tests/test_services.py"
      to: "custom_components/argos_translate/services.py"
      via: "async_register_services + hass.services.async_call"
      pattern: "async_register_services"
    - from: "tests/test_sensor.py"
      to: "custom_components/argos_translate/sensor.py"
      via: "direct entity instantiation"
      pattern: "ArgosLanguageCountSensor"
---

<objective>
Fix all stale template test references and add comprehensive test coverage for LibreTranslate-specific logic across config flow, coordinator, services, and sensors.

Purpose: Tests must pass for CI (DIST-03) and validate that Phases 1 and 2 implementations work correctly.
Output: 5 test files (3 fixed, 2 new) all passing with `pytest tests/`.
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-polish-validation/03-RESEARCH.md
@custom_components/argos_translate/config_flow.py
@custom_components/argos_translate/coordinator.py
@custom_components/argos_translate/services.py
@custom_components/argos_translate/sensor.py
@custom_components/argos_translate/binary_sensor.py
@custom_components/argos_translate/api.py
@custom_components/argos_translate/const.py
@custom_components/argos_translate/__init__.py
@tests/conftest.py
@tests/test_config_flow.py
@tests/test_coordinator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix existing tests and add shared fixtures</name>
  <files>
    tests/conftest.py
    tests/test_config_flow.py
    tests/test_coordinator.py
  </files>
  <action>
**conftest.py** — Add shared fixtures used by all test files:
- Keep existing `auto_enable_custom_integrations` and `mock_setup_entry` fixtures
- Add `mock_config_entry` fixture returning `MockConfigEntry(domain=DOMAIN, title="Test LibreTranslate", data={CONF_HOST: "192.168.1.100", CONF_PORT: 5000, CONF_API_KEY: "", CONF_NAME: "Test LibreTranslate", CONF_USE_SSL: False})`
- Add module-level `MOCK_LANGUAGES` constant: `[{"code": "en", "name": "English", "targets": ["es", "fr"]}, {"code": "es", "name": "Spanish", "targets": ["en"]}, {"code": "fr", "name": "French", "targets": ["en", "es"]}]`
- Import `CONF_NAME` from `homeassistant.const`, `CONF_USE_SSL` from `custom_components.argos_translate.const`

**test_config_flow.py** — Fix stale values and add missing test cases:
- Add `from homeassistant.const import CONF_NAME` import
- Add `from custom_components.argos_translate.const import CONF_USE_SSL` import
- Add `from custom_components.argos_translate.config_flow import InvalidAuth, NoLanguages` imports
- In `test_form`: change port 8080 → 5000, add `CONF_NAME: "My LibreTranslate"` and `CONF_USE_SSL: False` to user_input, update `result["data"]` assertion to include CONF_NAME and CONF_USE_SSL
- In `test_form_cannot_connect`: change port 8080 → 5000, add `CONF_NAME: "My LibreTranslate"` and `CONF_USE_SSL: False` to user_input
- In `test_form_duplicate_abort`: change unique_id and ports from 8080 → 5000, add CONF_NAME and CONF_USE_SSL to both existing entry data and user_input
- Add `test_form_invalid_auth`: same as cannot_connect but `_async_validate_connection` raises `InvalidAuth`, assert `errors["base"] == "invalid_auth"`
- Add `test_form_no_languages`: same pattern, raises `NoLanguages`, assert `errors["base"] == "no_languages"`
- In `test_options_flow`: change port 8080 → 5000, add `CONF_NAME: "My LibreTranslate"` to entry data, add `CONF_USE_SSL: False` to entry data, patch `_async_validate_connection` to return None during options configure, update assertion to check merged data

**test_coordinator.py** — Fix broken template references:
- Change import from `TemplateCoordinator` → `ArgosCoordinator` (from `custom_components.argos_translate.coordinator`)
- Add import for `CONF_USE_SSL` from `custom_components.argos_translate.const` and `CONF_NAME` from `homeassistant.const`
- In both tests: change port 8080 → 5000, add `CONF_NAME: "Test"` and `CONF_USE_SSL: False` to entry data
- In `test_coordinator_update`: change patch target from `coordinator.ApiClient.async_get_data` → `coordinator.ArgosTranslateApiClient.async_get_languages`, change `mock_data` from `{"sensor_value": 42, "status": "ok"}` → actual mock_languages list `[{"code": "en", "name": "English", "targets": ["es"]}, {"code": "es", "name": "Spanish", "targets": ["en"]}]`, change class instantiation from `TemplateCoordinator(hass, entry)` → `ArgosCoordinator(hass, entry)`, update assertion to check `coordinator.data == {"languages": mock_languages, "language_count": 2}`
- In `test_coordinator_update_failed`: change patch target same as above, change class to `ArgosCoordinator(hass, entry)`

Run `pytest tests/test_config_flow.py tests/test_coordinator.py -v` after each file to confirm fixes work incrementally.
  </action>
  <verify>
Run `pytest tests/conftest.py tests/test_config_flow.py tests/test_coordinator.py -v` — all tests pass. Specifically:
- test_form creates entry with port 5000 and CONF_NAME
- test_form_cannot_connect shows cannot_connect error
- test_form_invalid_auth shows invalid_auth error
- test_form_no_languages shows no_languages error
- test_form_duplicate_abort aborts
- test_options_flow updates data with validation
- test_coordinator_update returns {languages, language_count} shape
- test_coordinator_update_failed raises UpdateFailed
  </verify>
  <done>All 3 existing test files updated with correct LibreTranslate class names, port 5000, CONF_NAME field, and new error state tests. Zero ImportErrors, zero assertion failures.</done>
</task>

<task type="auto">
  <name>Task 2: Create test_services.py and test_sensor.py</name>
  <files>
    tests/test_services.py
    tests/test_sensor.py
  </files>
  <action>
**test_services.py** — New file testing the translate service:

Structure: Import `async_register_services` from `custom_components.argos_translate.services`, `DOMAIN` from const, `MockConfigEntry`, `ServiceValidationError` from `homeassistant.exceptions`, `HomeAssistantError` from `homeassistant.exceptions`, `CannotConnectError` from `custom_components.argos_translate.api`.

Create helper `_setup_service(hass, mock_translated="Hola")`:
1. Create `MagicMock` coordinator with `.data = {"languages": MOCK_LANGUAGES, "language_count": len(MOCK_LANGUAGES)}` and `.async_translate = AsyncMock(return_value=mock_translated)`. Use MOCK_LANGUAGES = `[{"code": "en", "name": "English", "targets": ["es", "fr"]}, {"code": "es", "name": "Spanish", "targets": ["en"]}]`
2. Create `MagicMock` runtime_data with `.coordinator = mock_coordinator`
3. Create `MockConfigEntry(domain=DOMAIN, data={CONF_HOST: "localhost", CONF_PORT: 5000})`, add to hass, set `entry.runtime_data = mock_runtime_data`
4. Call `async_register_services(hass)`
5. Return (entry, mock_coordinator) tuple for test access

Tests to write:
- `test_translate_success`: Call `hass.services.async_call(DOMAIN, "translate", {"text": "Hello", "source": "en", "target": "es"}, blocking=True, return_response=True)`. Assert result == `{"translated_text": "Hola"}`. Assert `mock_coordinator.async_translate` called with ("Hello", "en", "es").
- `test_translate_invalid_source`: Call with source="xx". Assert `pytest.raises(ServiceValidationError)`.
- `test_translate_invalid_target`: Call with source="en", target="xx". Assert `pytest.raises(ServiceValidationError)`.
- `test_translate_api_error`: After setup, change `mock_coordinator.async_translate` to `AsyncMock(side_effect=CannotConnectError("timeout"))`. Call with valid source/target. Assert `pytest.raises(HomeAssistantError)`.
- `test_translate_no_config_entry`: Register service but DON'T add any config entry to hass. Call service. Assert `pytest.raises(ServiceValidationError)`.

**test_sensor.py** — New file testing sensor entities directly (no state machine, per research guidance on disabled-by-default sensors):

Structure: Import `ArgosLanguageCountSensor` from `custom_components.argos_translate.sensor`, `ArgosStatusSensor` from `custom_components.argos_translate.binary_sensor`, `MockConfigEntry`, `MagicMock`.

Create helper `make_coordinator(languages=None, success=True)`:
1. Default languages = `[{"code": "en", "name": "English", "targets": ["es"]}, {"code": "es", "name": "Spanish", "targets": ["en"]}]`
2. `coordinator = MagicMock()`, `coordinator.last_update_success = success`
3. If success: `coordinator.data = {"languages": languages, "language_count": len(languages)}`
4. If not success: `coordinator.data = None`
5. Return coordinator

Tests for ArgosLanguageCountSensor:
- `test_language_count_value`: Create sensor with 2-language coordinator, assert `sensor.native_value == 2`
- `test_language_count_attributes`: Assert `sensor.extra_state_attributes` contains "languages" (list of names), "language_codes" (list of codes), "language_targets" (dict mapping codes to target lists)
- `test_language_count_no_data`: Create with success=False coordinator, assert `sensor.native_value is None` and `sensor.extra_state_attributes is None`
- `test_language_count_unique_id`: Assert `sensor.unique_id` == `"{entry_id}_language_count"`
- `test_language_count_disabled_by_default`: Assert `sensor._attr_entity_registry_enabled_default is False`

Tests for ArgosStatusSensor:
- `test_status_sensor_online`: Create with success=True, assert `sensor.is_on is True`
- `test_status_sensor_offline`: Create with success=False, assert `sensor.is_on is False`
- `test_status_sensor_unique_id`: Assert `sensor.unique_id` == `"{entry_id}_status"`
- `test_status_sensor_device_class`: Assert `sensor.device_class == BinarySensorDeviceClass.CONNECTIVITY`

For all sensor tests, create entry with `MockConfigEntry(domain=DOMAIN, data={}, entry_id="test_entry_123")`.

Run `pytest tests/test_services.py tests/test_sensor.py -v` after creating each file.
  </action>
  <verify>
Run `pytest tests/ -v` — ALL tests across ALL 5 files pass. Expected test count: approximately 18-20 tests total.

Specifically verify:
- `pytest tests/test_services.py -v` passes 5 tests (success, invalid_source, invalid_target, api_error, no_config_entry)
- `pytest tests/test_sensor.py -v` passes 9 tests (count_value, count_attrs, count_no_data, count_unique_id, count_disabled, status_online, status_offline, status_unique_id, status_device_class)
  </verify>
  <done>Two new test files created. Service tests validate translation success, language pair validation errors, API errors, and missing config entry. Sensor tests validate entity values, attributes, null states, unique IDs, and device class. Full `pytest tests/` green.</done>
</task>

</tasks>

<verification>
1. `pytest tests/ -v` — all tests pass, zero failures
2. No `ImportError` from stale template references (TemplateCoordinator, ApiClient.async_get_data)
3. All config flow tests use port 5000 and include CONF_NAME
4. Service tests cover success + 3 error paths + missing entry
5. Sensor tests cover value + attrs + null state + metadata for both entity types
</verification>

<success_criteria>
- `pytest tests/ -v` exits with code 0 and all tests passing
- Config flow error states (InvalidAuth, NoLanguages) have test coverage
- Translate service tested with return_response=True pattern
- Sensor entities tested via direct instantiation (not state machine) due to disabled-by-default
</success_criteria>

<output>
After completion, create `.planning/phases/03-polish-validation/03-01-SUMMARY.md`
</output>
