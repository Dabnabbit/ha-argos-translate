---
phase: 02-translation-service-card
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - custom_components/argos_translate/const.py
  - custom_components/argos_translate/services.py
  - custom_components/argos_translate/services.yaml
  - custom_components/argos_translate/sensor.py
  - custom_components/argos_translate/strings.json
  - custom_components/argos_translate/translations/en.json
autonomous: true
requirements: [SRVC-01, SRVC-02, SRVC-03, SRVC-04]

must_haves:
  truths:
    - "argos_translate.translate service accepts text, source, and target parameters"
    - "Service returns {translated_text} via SupportsResponse.ONLY"
    - "Service validates language pair against coordinator data before calling API"
    - "Service returns clear error for invalid language pair"
    - "Service returns clear error when server is unreachable"
    - "Language count sensor includes language_targets attribute mapping source codes to target code lists"
  artifacts:
    - path: "custom_components/argos_translate/services.py"
      provides: "Translate service handler with language validation"
      contains: "SupportsResponse.ONLY"
    - path: "custom_components/argos_translate/services.yaml"
      provides: "Translate service schema definition"
      contains: "translate"
    - path: "custom_components/argos_translate/const.py"
      provides: "Service and field name constants"
      contains: "SERVICE_TRANSLATE"
    - path: "custom_components/argos_translate/sensor.py"
      provides: "Language targets in extra_state_attributes"
      contains: "language_targets"
    - path: "custom_components/argos_translate/strings.json"
      provides: "Service name and field descriptions"
      contains: "services"
  key_links:
    - from: "custom_components/argos_translate/services.py"
      to: "custom_components/argos_translate/coordinator.py"
      via: "entry.runtime_data.coordinator.async_translate()"
      pattern: "coordinator\\.async_translate"
    - from: "custom_components/argos_translate/services.py"
      to: "custom_components/argos_translate/coordinator.py"
      via: "coordinator.data[languages] for validation"
      pattern: "coordinator\\.data"
    - from: "custom_components/argos_translate/__init__.py"
      to: "custom_components/argos_translate/services.py"
      via: "async_register_services(hass) in async_setup"
      pattern: "async_register_services"
---

<objective>
Implement the `argos_translate.translate` service with SupportsResponse.ONLY pattern, language pair validation, and clear error messages. Also add language_targets attribute to the language count sensor for downstream card use.

Purpose: Enable programmatic text translation via HA service calls and Developer Tools
Output: Working translate service callable from automations and Developer Tools, sensor attribute with target language mappings
</objective>

<execution_context>
@/home/dab/.claude/get-shit-done/workflows/execute-plan.md
@/home/dab/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@custom_components/argos_translate/services.py
@custom_components/argos_translate/services.yaml
@custom_components/argos_translate/const.py
@custom_components/argos_translate/sensor.py
@custom_components/argos_translate/coordinator.py
@custom_components/argos_translate/api.py
@custom_components/argos_translate/__init__.py
@custom_components/argos_translate/strings.json
@custom_components/argos_translate/translations/en.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add service constants and update services.py with translate handler</name>
  <files>
    custom_components/argos_translate/const.py
    custom_components/argos_translate/services.py
    custom_components/argos_translate/services.yaml
  </files>
  <action>
    **const.py:** Add service and field constants:
    ```python
    SERVICE_TRANSLATE = "translate"
    ATTR_TEXT = "text"
    ATTR_SOURCE = "source"
    ATTR_TARGET = "target"
    ```

    **services.py:** Complete rewrite to replace the template "query" service with "translate":

    1. Remove the old SERVICE_QUERY, SERVICE_SCHEMA, and _async_handle_query code entirely.

    2. Import required modules:
       ```python
       from homeassistant.exceptions import ServiceValidationError, HomeAssistantError
       from .const import DOMAIN, SERVICE_TRANSLATE, ATTR_TEXT, ATTR_SOURCE, ATTR_TARGET
       ```

    3. Define the service schema:
       ```python
       SERVICE_SCHEMA = vol.Schema({
           vol.Required(ATTR_TEXT): cv.string,
           vol.Required(ATTR_SOURCE): cv.string,
           vol.Required(ATTR_TARGET): cv.string,
       })
       ```

    4. Create the async handler function (NOT decorated with @callback since it's async):
       ```python
       async def _async_handle_translate(call: ServiceCall) -> ServiceResponse:
       ```
       - Look up config entries: `hass.config_entries.async_entries(DOMAIN)`
       - If no entries, raise `ServiceValidationError(translation_domain=DOMAIN, translation_key="no_config_entry")`
       - Get coordinator from first entry: `entries[0].runtime_data.coordinator`
       - Get language data from coordinator: `coordinator.data.get("languages", [])`
       - Validate source language exists in the language list (match by code field)
       - If not found: raise `ServiceValidationError(translation_domain=DOMAIN, translation_key="invalid_source", translation_placeholders={"source": source})`
       - Validate target is in the source language's `targets` list
       - If not found: raise `ServiceValidationError(translation_domain=DOMAIN, translation_key="invalid_target", translation_placeholders={"source": source, "target": target})`
       - Call `coordinator.async_translate(text, source, target)` wrapped in try/except
       - Catch `CannotConnectError` and re-raise as `HomeAssistantError(f"Translation failed: {err}")`
       - Return `{"translated_text": result}`

    5. Update the registration function — remove `@callback` decorator (the handler is async):
       ```python
       def async_register_services(hass: HomeAssistant) -> None:
           async def _async_handle_translate(call: ServiceCall) -> ServiceResponse:
               # ... handler as nested function so it has access to hass ...

           hass.services.async_register(
               DOMAIN,
               SERVICE_TRANSLATE,
               _async_handle_translate,
               schema=SERVICE_SCHEMA,
               supports_response=SupportsResponse.ONLY,
           )
       ```

    NOTE: The handler function is defined INSIDE async_register_services so it captures `hass` from the enclosing scope. The outer function can keep `@callback` since it itself is synchronous — only the inner handler is async.

    **services.yaml:** Replace entirely:
    ```yaml
    translate:
      fields:
        text:
          required: true
          example: "Hello, how are you?"
          selector:
            text:
              multiline: true
        source:
          required: true
          example: "en"
          selector:
            text:
        target:
          required: true
          example: "es"
          selector:
            text:
    ```
  </action>
  <verify>
    - Verify services.py has no syntax errors: `python3 -c "import ast; ast.parse(open('custom_components/argos_translate/services.py').read())"`
    - Grep for SupportsResponse.ONLY in services.py
    - Grep for SERVICE_TRANSLATE in const.py
    - Verify services.yaml is valid YAML: `python3 -c "import yaml; yaml.safe_load(open('custom_components/argos_translate/services.yaml').read())"`
    - Verify no remnants of old "query" service in services.py or services.yaml
  </verify>
  <done>
    - `argos_translate.translate` service registered with SupportsResponse.ONLY
    - Service schema requires text, source, target fields
    - Handler validates language pair against coordinator data
    - ServiceValidationError raised for invalid source, invalid target, no config entry
    - HomeAssistantError raised for connection/timeout failures
    - services.yaml defines translate with text (multiline), source, target fields
  </done>
</task>

<task type="auto">
  <name>Task 2: Add language_targets sensor attribute and update strings/translations</name>
  <files>
    custom_components/argos_translate/sensor.py
    custom_components/argos_translate/strings.json
    custom_components/argos_translate/translations/en.json
  </files>
  <action>
    **sensor.py:** Add `language_targets` to `extra_state_attributes` in `ArgosLanguageCountSensor`:
    - In the `extra_state_attributes` property, add a third key `language_targets` that maps each source language code to its list of target codes:
      ```python
      "language_targets": {
          lang["code"]: lang.get("targets", []) for lang in languages
      },
      ```
    - This gives the frontend card a way to know which target languages are valid for each source language without making API calls.

    **strings.json:** Add a `services` section at the top level (sibling to `config` and `options`):
    ```json
    "services": {
      "translate": {
        "name": "Translate text",
        "description": "Translate text between languages using LibreTranslate.",
        "fields": {
          "text": {
            "name": "Text",
            "description": "The text to translate."
          },
          "source": {
            "name": "Source language",
            "description": "The source language code (e.g., 'en' for English)."
          },
          "target": {
            "name": "Target language",
            "description": "The target language code (e.g., 'es' for Spanish)."
          }
        }
      }
    }
    ```
    Also add service error translations under a new top-level `exceptions` key:
    ```json
    "exceptions": {
      "no_config_entry": {
        "message": "No Argos Translate instance configured. Add one via Settings > Integrations."
      },
      "invalid_source": {
        "message": "Unknown source language: {source}"
      },
      "invalid_target": {
        "message": "Cannot translate from {source} to {target}. Target language is not available for this source."
      }
    }
    ```

    **translations/en.json:** Mirror the exact same additions as strings.json (same `services` and `exceptions` sections).
  </action>
  <verify>
    - Verify sensor.py has no syntax errors: `python3 -c "import ast; ast.parse(open('custom_components/argos_translate/sensor.py').read())"`
    - Grep for "language_targets" in sensor.py
    - Verify strings.json is valid JSON: `python3 -c "import json; json.load(open('custom_components/argos_translate/strings.json'))"`
    - Verify translations/en.json is valid JSON: `python3 -c "import json; json.load(open('custom_components/argos_translate/translations/en.json'))"`
    - Verify strings.json contains "services" key and "exceptions" key
    - Verify translations/en.json contains "services" key and "exceptions" key
  </verify>
  <done>
    - Language count sensor extra_state_attributes includes `language_targets` dict mapping source codes to target code lists
    - strings.json has service name/description and field descriptions for translate service
    - strings.json has exception messages for no_config_entry, invalid_source, invalid_target
    - translations/en.json mirrors strings.json additions exactly
  </done>
</task>

</tasks>

<verification>
- `SERVICE_TRANSLATE = "translate"` exists in const.py
- services.py contains `SupportsResponse.ONLY` and `ServiceValidationError`
- services.py handler validates source language exists, target in source's targets list
- services.yaml defines translate with text, source, target fields
- sensor.py extra_state_attributes includes language_targets dict
- strings.json and translations/en.json both have services and exceptions sections
- No remnants of old "query" service anywhere
- All .py files pass syntax check
- All .json files are valid JSON
- All .yaml files are valid YAML
</verification>

<success_criteria>
1. `argos_translate.translate` service is registered with SupportsResponse.ONLY
2. Service validates language pair before calling API
3. Service returns `{translated_text: "..."}` on success
4. Service raises ServiceValidationError for invalid source, invalid target, or no config entry
5. Service raises HomeAssistantError when server is unreachable
6. Language count sensor includes language_targets attribute for frontend use
7. All strings localized in strings.json and translations/en.json
</success_criteria>

<output>
After completion, create `.planning/phases/02-translation-service-card/02-01-SUMMARY.md`
</output>
